@page "/locationdatacopy"

@using threemillion.Data
@using System.Diagnostics
@*@inject LocationDataService LocationDataService*@

@using ReactClient
@using Grpc.Core
@using System.Threading
@inject ReactClient.LocationData.LocationDataClient LocationDataClient

@inject IJSRuntime JSRuntime;
@*@code { protected override void OnAfterRender(bool firstRender) { JSRuntime.InvokeVoidAsync("mapBoxFunctions.initMapBox"); }}*@

<div id='map' style="width: 100%; height: 70vh;"></div>

@if (locations == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <h1>@DataCount</h1>
    <span>Elapsed</span>
    <h1>@elapsed</h1>
    <span>Elapsed</span>
    <h1>@elp</h1>
    <div style="height:500px;overflow-y:scroll">
    </div>
    <table class="table">
        <thead>
            <tr>
                <th>Latitude</th>
                <th>Longitude</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var location in locations)
            {
                <tr>
                    <td>@location.Latitude)</td>
                    <td>@location.Longitude</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private List<Location> locations = new List<Location>();

    private int DataCount = 0;
    private DateTime elapsed = DateTime.UtcNow;
    private long elp = 0;
    Stopwatch watch = new Stopwatch();

    protected override async Task OnInitializedAsync()
    {
        @*await JSRuntime.InvokeVoidAsync("mapBoxFunctions.initMapBox");*@
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        await JSRuntime.InvokeVoidAsync("mapBoxFunctions.initMapBox");

        watch.Start();
        @*using (var call = LocationDataClient.GetLocationData(new GetLocationRequest { DataLimit = 1000000 }))*@

        using (var call = LocationDataClient.GetAllLocationData(new GetAllLocationsRequest()))
        {
            @* Thread.Sleep(10); *@

            var list = new List<object>();

            var count = 0;

            await foreach (var response in call.ResponseStream.ReadAllAsync())
            {
                @*locations.Add(new Location
                    {
                        Latitude = response.LatitudeE7,
                        Longitude = response.LongitudeE7
                    });*@

                @*Thread.Sleep(1000);*@

                var pow = Math.Pow(10, 7);
                var a = response.LongitudeE7 / pow;
                var b = response.LatitudeE7 / pow;

                list.Add(new
                {
                    type = "Feature",
                    geometry = new
                    {
                        type = "Point",
                        coordinates = new double[] { a, b }
                    }
                });

                @*list.Add(new int[] { response.LongitudeE7, response.LatitudeE7 });*@
                count++;

                if (count == 100000)
                {
                    await JSRuntime.InvokeVoidAsync("mapBoxFunctions.addMarker", list);
                    count = 0;
                }

                DataCount++;

                @*await UpdateTime();*@

                @*Thread.Sleep(1000);*@



                @*await JSRuntime.InvokeVoidAsync("mapBoxFunctions.addMarker", new int[] { response.LongitudeE7, response.LatitudeE7 });*@
            }

            await UpdateTime();
        }

        watch.Stop();



        @*return Task.FromResult(true);*@
    }

    public async Task UpdateTime()
    {
        await InvokeAsync(() =>
        {

            elapsed = DateTime.UtcNow;
            elp = watch.ElapsedMilliseconds / 1000;


            StateHasChanged();
        });
    }
}
